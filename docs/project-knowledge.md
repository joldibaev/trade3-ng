# Обзор проекта: Trade3-NG

Этот документ содержит полный обзор проекта `trade3-ng`, основанный на анализе кодовой базы и проверках, выполненных ИИ-ассистентом.

## 1. Стек технологий

- **Фреймворк**: Angular v21 (последние версии bleeding edge/nightly в `package.json`).
- **Язык**: TypeScript ~5.9.
- **Стилизация**: Tailwind CSS v4.
  - Настроен в `src/styles.css` с использованием новых директив `@theme` и `@import`.
  - Использует нативные CSS-переменные для темизации (например, `--color-primary-500`).
- **Иконки**: Кастомная SVG система.
  - Используются **только** иконки [Tabler Icons](https://tabler.io/icons). Исходные SVG находятся в `src/assets/img/svg`.
  - Генерация/Оптимизация через `npm run icons:sync` (выполняет `scripts/generate-icons/index.js`).
  - Используются через компонент `UiIcon`.
- **HTTP Клиент**: Angular `HttpClient` с интерцепторами.
- **Управление состоянием**: Angular Signals (`signal`, `computed`, `effect`). Тяжелых внешних сторов (NGRX/Elf) не замечено, используется сервис-ориентированное управление на сигналах.

## 2. Структура проекта

Проект следует масштабируемой архитектуре Angular:

### `src/app/core`

Содержит синглтон-сервисы, глобальные конфигурации и базовые UI компоненты.

- **`interceptors/`**:
  - `http.interceptor.ts`: Обрабатывает глобальные HTTP ответы. Автоматически перехватывает ошибки API и отображает их через `UiNotyfService`. Обрабатывает стандартные структуры `ApiResponse`.
- **`ui/`**: Переиспользуемые примитивные UI компоненты.
  - `ui-button`, `ui-input`, `ui-dialog`, `ui-card` и т.д.
  - **`ui-notyf`**: Кастомная система уведомлений (тостов), стилизованная под интерфейс "1С Предприятие".
  - **`ui-icon`**: Компонент для рендеринга SVG из сгенерированного бандла иконой.
  - **`ui-table`**: Базовый компонент таблицы для отображения данных.

### `src/app/features`

Содержит модули и страницы конкретной функциональности.

- **`core/`**: Основная оболочка (layout) приложения.
  - Компонент `Core`: Формирует боковую панель (`Aside`), область основного контента (`router-outlet`) и глобальные элементы, такие как `<ui-notyf/>`.
  - **`components/`**:
    - **`table-struct`**: Переиспользуемый компонент-обертка для создания страниц с таблицами. Он инкапсулирует шаблон "Header + Toolbar + Search + Table" и предоставляет слоты для кастомизации. Используется для стандартизации страниц справочников. Аутпуты именуются в прошедшем времени: `created`, `edited`, `deleted`, `searched`.
  - **`pages/`**:
    - `dashboard-page`: Главная панель.
    - **`directories-page`**: Управление справочниками системы. Большинство страниц (`ClientsPage`, `VendorsPage`, `PriceTypesPage`) рефакторены для использования `TableStructComponent`.
      - **Исключения**: `StoresPage` и `CashboxesPage` используют карточный (grid) лейаут (`UiDirectoryItemCard`) вместо табличного, сохраняя уникальный дизайн.
    - `documents-page`: Обработка документов.

### `src/app/shared`

Содержит общие утилиты и типы, используемые в разных фичах.

- **`interfaces/`**: Описания доменных сущностей.
  - `entities/`: Интерфейсы `Product`, `Price`, `StockMovement`, `Document*`.
  - `constants.ts`: Перечисления (Enums), такие как `DocumentStatus`, `BarcodeType`, `StockMovementType`.
  - **`dtos/`**: Объекты передачи данных (Data Transfer Objects), используемые для создания и обновления сущностей.
    - Содержит файлы `create-*.interface.ts` и `update-*.interface.ts` (например, `create-product.interface.ts`, `update-client.interface.ts`).
    - Обеспечивает типизацию полезной нагрузки (payload) при отправке данных на сервер, отделяя их от полных доменных сущностей.
  - **`dialogs/`**: Контракты данных для диалоговых окон.
    - Определяют два интерфейса для каждого диалога:
      - `*DialogData`: Данные, передаваемые _в_ диалог при открытии (через `DIALOG_DATA`).
      - `*DialogResult`: Данные, возвращаемые _из_ диалога при закрытии (через `dialogRef.close(result)`).
    - Пример: `store-dialog.interface.ts` (содержит `StoreDialogData` и `StoreDialogResult`).

## 3. Ключевые концепции и соглашения

### UI Компоненты

- **Диалоговые окна (`ui-dialog`)**:
  - **Архитектура**: Построены на базе `@angular/cdk/dialog`.
  - **Компонент-обертка**: `UiDialog` — это презентационный компонент, обеспечивающий единый стиль (заголовок, drag-handle, контейнер).
  - **Реализация Feature-диалогов**:
    - Feature-диалоги (например, `StoreDialog`) используют `UiDialog` в шаблоне.
    - Инъекция данных: Используют токен `DIALOG_DATA` для получения входных параметров (`inject<StoreDialogData>(DIALOG_DATA)`).
    - Возврат результата: Используют `DialogRef<StoreDialogResult>` для закрытия и возврата данных.
    - Бизнес-логика: Внутри диалога часто происходит вызов сервисов (`create`/`update`), и диалог закрывается только после успешного ответа сервера.
- **Стилизация и Темизация**
  - **Tailwind v4**: Проект использует современную конфигурацию Tailwind v4 напрямую в CSS.
- **Стиль**: Проект использует собственный дизайн, вдохновленный **shadcn ui** (минимализм, чистые линии, фокус на контенте). От стиля "1С Предприятие" решено отказаться.
- **Кастомные утилиты**:
  - `rounded-squircle`: Скругление углов (super-ellipse).
  - `text-muted`: Приглушенный цвет текста (второстепенная информация).
  - `default-transition`: Стандартная анимация переходов.
  - `default-border-color`: Стандартный цвет границ.
  - `typo-h1`: Типографика для заголовков первого уровня.

### Обработка ошибок

- **Глобальный Интерцептор**: `httpInterceptor` обрабатывает `HttpErrorResponse`.
- **Логика обработки**:
  - Проверяет `success: false` в теле ответа API.
  - Перехватывает фактические ошибки HTTP (400, 500).
  - Извлекает сообщения об ошибках (`message` или `title`) и показывает их через `UiNotyfService.error()`.

### Работа с датой и временем

- **Часовой пояс**: Проект жестко привязан к часовому поясу Узбекистана (**UTC+5**).
- **Утилиты**:
  - `src/app/shared/utils/get-current-date-as-string.ts`: Содержит функцию `getCurrentDateAsString`, которая конвертирует дату в строку формата `YYYY-MM-DDTHH:mm` (для `input type="datetime-local"`), принудительно добавляя смещение +5 часов к UTC времени. Это гарантирует, что независимо от локального времени браузера пользователя, дефолтные значения в формах будут соответствовать времени Ташкента.

### Стандарты кода (`.gemini/GEMINI.md`)

Проект придерживается строгих правил кодирования:

- **Signals**: Обязательное использование сигналов для состояния.
- **Standalone**: Все компоненты должны быть standalone.
- **Control Flow**: Использование нового синтаксиса `@if`, `@for`.
- **Доступность (A11y)**: Строгое соблюдение ARIA ролей, лейблов и контрастности (недавно применено к `ui-notyf`).
- **Типизация**: Strict mode, отсутствие `any` (использовать `unknown`), явные интерфейсы.

## 4. Скрипты автоматизации

- **`npm run icons:sync`**: Сканирует `src/assets/img/svg`, оптимизирует их и генерирует TypeScript бандл `data.ts` для компонента `UiIcon`. Это позволяет использовать типизированные имена иконок.

## 5. Новые паттерны (Form & UI)

### Signal Forms (`@angular/forms/signals`)
Проект переходит на использование Signal Forms для управления состоянием форм.
- **Инициализация**: Используется функция `form` для создания группы формы на основе сигнала состояния.
  ```typescript
  formState = signal({ ... });
  formData = form(this.formState, (schema) => {
    required(schema.field, { message: '...' });
  });
  ```
- **Интеграция с UI**:
  - `UiSelect` и `UiInput` поддерживают привязку `[formField]`.
  - Для работы `[formField]` необходимо импортировать директиву `FormField` из `@angular/forms/signals` в `imports` массива компонента.
  - Валидация в шаблоне: `[disabled]="!formData().valid()"`.

### Управление состоянием загрузки
Использовать оператор `finalize` для сброса флага загрузки, чтобы гарантировать корректное состояние UI при любом исходе запроса.
```typescript
this.service.call().pipe(
  finalize(() => this.isLoading.set(false))
).subscribe(...)
```

### Работа с датами
Для полей даты использовать `ui-input` с типом `datetime-local` (или `date`).
- Значение инициализируется через утилиту `getCurrentDateAsString()`.
- В DTO передается строковое значение напрямую, если формат совпадает.

### Инъекция зависимостей
Сервисы, внедряемые через `inject()`, должны быть помечены как `private`, если они не используются напрямую в шаблоне.

### Получение данных (Data Fetching)
Сервисы, наследуемые от `BaseService`, поддерживают подгрузку связей (relations) через параметр `includes`.
- **Пример**: `this.service.getAll({ includes: ['vendor', 'store'] })`.
- Это добавляет query-параметры `?include=vendor&include=store` к запросу.
